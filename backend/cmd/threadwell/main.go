// @title ThreadWell API
// @version 0.1
// @description Local threaded conversation backend
// @BasePath /api
package main

import (
    "log"
    "net/http"

    "github.com/swaggo/http-swagger"
    _ "github.com/krackenservices/threadwell/docs" // generated by swag init
    "github.com/krackenservices/threadwell/api"
    "github.com/krackenservices/threadwell/config"
    "github.com/krackenservices/threadwell/storage"
    "github.com/krackenservices/threadwell/storage/memory"
    "github.com/krackenservices/threadwell/storage/sqlite"
)

var store storage.Storage

func withCORS(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*") // or your frontend origin
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

		// Handle preflight
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func main() {
    cfg := config.Load()

    var err error
    switch cfg.Storage.Type {
    case "sqlite":
        store, err = sqlite.New(cfg.Storage.Path)
    case "memory":
        store = memory.New()
    default:
        log.Println("unsupported or undefined storage type: '%s' - Defaulting to Memory", cfg.Storage.Type)
        store = memory.New()
    }
    if err != nil {
        log.Fatalf("storage init error: %v", err)
    }

    mux := http.NewServeMux()
    api.RegisterRoutes(mux, store)

    mux.Handle("/swagger/", httpSwagger.WrapHandler)
    mux.HandleFunc("/swagger.json", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "./docs/swagger.json")
    })

    log.Println("Listening on :8001")
    if err := http.ListenAndServe(":8001", withCORS(mux)); err != nil {
        log.Fatal(err)
    }
}
